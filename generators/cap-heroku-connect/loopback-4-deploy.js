const Generator = require('yeoman-generator');
const astUtilities = require('../app/utils/AST-files');
const { exec } = require('promisify-child-process');
const loading = require('loading-cli');

let load = null;
let path = '';
let appName = '';
let deploy = {};

module.exports = class extends Generator {
  constructor(args, opts) {
    super(args, opts);
    path = opts.path;
    appName = opts.appName;
    deploy = opts.deploy;
    console.log('deploy: ', deploy);
  }

  async prompting() {}

  async writing() {
    try {
      load = loading('Preparing the files to deploy the application'.blue).start();
      await astUtilities.astFunctions.replaceText(
        this.destinationPath(`${path}/.gitignore`),
        `
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Typescript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# Transpiled JavaScript files from Typescript

# Cache used by TypeScript's incremental build
*.tsbuildinfo

        `
      );

      // File.set('scripts.start', `node .`);
      let fileRoot = this.destinationPath(`${path}/package.json`);
      await astUtilities.astFunctions.editJSONFile(fileRoot, 'scripts.start', 'node .');
      load.stop();
      load.succeed('Successfully preparation of the files');
    } catch (error) {
      load.stop();
      load.fail(error);
      console.log('error: ', error);
    }
  }

  async installDependencies() {
    try {
      load = loading('Installing dependencies'.blue).start();
      await exec('npm install', {
        cwd: this.destinationPath(path)
      });
      load.stop();
      load.succeed('Successfully installation');
    } catch (error) {
      load.stop();
      console.log('error: ', error);
      load.fail(error);
    }
  }

  async end() {
    try {
      load = loading('Configuring the variables'.blue).start();

      await exec(`heroku config:set ${deploy.key}=${deploy.value} -a ${appName}`, {
        cwd: this.destinationPath(path)
      });
      load.stop();
      load.succeed('Successfully configuration');

      load = loading('Deploying application'.blue).start();
      await exec('git init', {
        cwd: this.destinationPath(path)
      });

      await exec('npm run build', {
        cwd: this.destinationPath(path)
      });

      await exec('git add -A', {
        cwd: this.destinationPath(path),
        maxBuffer: 2000 * 1024
      });

      await exec(`git commit -m "First commit"`, {
        cwd: this.destinationPath(path),
        maxBuffer: 2000 * 1024
      });

      await exec(`heroku git:remote -a ${appName}`, {
        cwd: this.destinationPath(path),
        maxBuffer: 2000 * 1024
      });

      let deployStatus = await exec('git push heroku master', {
        cwd: this.destinationPath(path),
        maxBuffer: 2000 * 1024
      });
      load.stop();
      load.succeed('Successfully deployment');
      this.log(`HEROKU DEPLOY STATUS`, deployStatus.stderr.toString());
    } catch (error) {
      load.stop();
      console.log('error: ', error);
      load.fail(error);
    }
  }
};
